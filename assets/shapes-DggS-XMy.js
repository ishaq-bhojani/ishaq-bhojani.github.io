import{i as Pe,u as be,_ as te,s as we,V as F,e as Se,x as ne,O as re}from"./extends-D2_nY6Nc.js";import{r as n,c as Ee}from"./index-DUjezpEW.js";const C=new F,B=new F,We=new F,ee=new Se;function je(e,t,s){const i=C.setFromMatrixPosition(e.matrixWorld);i.project(t);const o=s.width/2,a=s.height/2;return[i.x*o+o,-(i.y*a)+a]}function Ce(e,t){const s=C.setFromMatrixPosition(e.matrixWorld),i=B.setFromMatrixPosition(t.matrixWorld),o=s.sub(i),a=t.getWorldDirection(We);return o.angleTo(a)>Math.PI/2}function Re(e,t,s,i){const o=C.setFromMatrixPosition(e.matrixWorld),a=o.clone();a.project(t),ee.set(a.x,a.y),s.setFromCamera(ee,t);const h=s.intersectObjects(i,!0);if(h.length){const v=h[0].distance;return o.distanceTo(s.ray.origin)<v}return!0}function Oe(e,t){if(t instanceof re)return t.zoom;if(t instanceof ne){const s=C.setFromMatrixPosition(e.matrixWorld),i=B.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,a=s.distanceTo(i);return 1/(2*Math.tan(o/2)*a)}else return 1}function $e(e,t,s){if(t instanceof ne||t instanceof re){const i=C.setFromMatrixPosition(e.matrixWorld),o=B.setFromMatrixPosition(t.matrixWorld),a=i.distanceTo(o),h=(s[1]-s[0])/(t.far-t.near),v=s[1]-h*t.far;return Math.round(h*a+v)}}const k=e=>Math.abs(e)<1e-10?0:e;function se(e,t,s=""){let i="matrix3d(";for(let o=0;o!==16;o++)i+=k(t[o]*e.elements[o])+(o!==15?",":")");return s+i}const He=(e=>t=>se(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Te=(e=>(t,s)=>se(t,e(s),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Fe(e){return e&&typeof e=="object"&&"current"in e}const Ae=n.forwardRef(({children:e,eps:t=.001,style:s,className:i,prepend:o,center:a,fullscreen:h,portal:v,distanceFactor:E,sprite:oe=!1,transform:x=!1,occlude:c,onOcclude:L,castShadow:ie,receiveShadow:ae,material:ce,geometry:N,zIndexRange:R=[16777271,0],calculatePosition:Z=je,as:le="div",wrapperClass:z,pointerEvents:G="auto",...y},_)=>{const{gl:q,camera:l,scene:J,size:f,raycaster:ue,events:fe,viewport:de}=Pe(),[u]=n.useState(()=>document.createElement(le)),A=n.useRef(),m=n.useRef(null),K=n.useRef(0),O=n.useRef([0,0]),W=n.useRef(null),D=n.useRef(null),w=(v==null?void 0:v.current)||fe.connected||q.domElement.parentNode,g=n.useRef(null),$=n.useRef(!1),H=n.useMemo(()=>c&&c!=="blending"||Array.isArray(c)&&c.length&&Fe(c[0]),[c]);n.useLayoutEffect(()=>{const d=q.domElement;c&&c==="blending"?(d.style.zIndex=`${Math.floor(R[0]/2)}`,d.style.position="absolute",d.style.pointerEvents="none"):(d.style.zIndex=null,d.style.position=null,d.style.pointerEvents=null)},[c]),n.useLayoutEffect(()=>{if(m.current){const d=A.current=Ee(u);if(J.updateMatrixWorld(),x)u.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const r=Z(m.current,l,f);u.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${r[0]}px,${r[1]}px,0);transform-origin:0 0;`}return w&&(o?w.prepend(u):w.appendChild(u)),()=>{w&&w.removeChild(u),d.unmount()}}},[w,x]),n.useLayoutEffect(()=>{z&&(u.className=z)},[z]);const Q=n.useMemo(()=>x?{position:"absolute",top:0,left:0,width:f.width,height:f.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...h&&{top:-f.height/2,left:-f.width/2,width:f.width,height:f.height},...s},[s,a,h,f,x]),me=n.useMemo(()=>({position:"absolute",pointerEvents:G}),[G]);n.useLayoutEffect(()=>{if($.current=!1,x){var d;(d=A.current)==null||d.render(n.createElement("div",{ref:W,style:Q},n.createElement("div",{ref:D,style:me},n.createElement("div",{ref:_,className:i,style:s,children:e}))))}else{var r;(r=A.current)==null||r.render(n.createElement("div",{ref:_,style:Q,className:i,children:e}))}});const S=n.useRef(!0);be(d=>{if(m.current){l.updateMatrixWorld(),m.current.updateWorldMatrix(!0,!1);const r=x?O.current:Z(m.current,l,f);if(x||Math.abs(K.current-l.zoom)>t||Math.abs(O.current[0]-r[0])>t||Math.abs(O.current[1]-r[1])>t){const M=Ce(m.current,l);let p=!1;H&&(Array.isArray(c)?p=c.map(P=>P.current):c!=="blending"&&(p=[J]));const j=S.current;if(p){const P=Re(m.current,l,ue,p);S.current=P&&!M}else S.current=!M;j!==S.current&&(L?L(!S.current):u.style.display=S.current?"block":"none");const T=Math.floor(R[0]/2),he=c?H?[R[0],T]:[T-1,0]:R;if(u.style.zIndex=`${$e(m.current,l,he)}`,x){const[P,X]=[f.width/2,f.height/2],I=l.projectionMatrix.elements[5]*X,{isOrthographicCamera:Y,top:xe,left:ve,bottom:ye,right:pe}=l,ge=He(l.matrixWorldInverse),Me=Y?`scale(${I})translate(${k(-(pe+ve)/2)}px,${k((xe+ye)/2)}px)`:`translateZ(${I}px)`;let b=m.current.matrixWorld;oe&&(b=l.matrixWorldInverse.clone().transpose().copyPosition(b).scale(m.current.scale),b.elements[3]=b.elements[7]=b.elements[11]=0,b.elements[15]=1),u.style.width=f.width+"px",u.style.height=f.height+"px",u.style.perspective=Y?"":`${I}px`,W.current&&D.current&&(W.current.style.transform=`${Me}${ge}translate(${P}px,${X}px)`,D.current.style.transform=Te(b,1/((E||10)/400)))}else{const P=E===void 0?1:Oe(m.current,l)*E;u.style.transform=`translate3d(${r[0]}px,${r[1]}px,0) scale(${P})`}O.current=r,K.current=l.zoom}}if(!H&&g.current&&!$.current)if(x){if(W.current){const r=W.current.children[0];if(r!=null&&r.clientWidth&&r!=null&&r.clientHeight){const{isOrthographicCamera:M}=l;if(M||N)y.scale&&(Array.isArray(y.scale)?y.scale instanceof F?g.current.scale.copy(y.scale.clone().divideScalar(1)):g.current.scale.set(1/y.scale[0],1/y.scale[1],1/y.scale[2]):g.current.scale.setScalar(1/y.scale));else{const p=(E||10)/400,j=r.clientWidth*p,T=r.clientHeight*p;g.current.scale.set(j,T,1)}$.current=!0}}}else{const r=u.children[0];if(r!=null&&r.clientWidth&&r!=null&&r.clientHeight){const M=1/de.factor,p=r.clientWidth*M,j=r.clientHeight*M;g.current.scale.set(p,j,1),$.current=!0}g.current.lookAt(d.camera.position)}});const U=n.useMemo(()=>({vertexShader:x?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[x]);return n.createElement("group",te({},y,{ref:m}),c&&!H&&n.createElement("mesh",{castShadow:ie,receiveShadow:ae,ref:g},N||n.createElement("planeGeometry",null),ce||n.createElement("shaderMaterial",{side:we,vertexShader:U.vertexShader,fragmentShader:U.fragmentShader})))});function V(e,t){const s=e+"Geometry";return n.forwardRef(({args:i,children:o,...a},h)=>{const v=n.useRef(null);return n.useImperativeHandle(h,()=>v.current),n.useLayoutEffect(()=>void(t==null?void 0:t(v.current))),n.createElement("mesh",te({ref:v},a),n.createElement(s,{attach:"geometry",args:i}),o)})}const De=V("box"),Ie=V("cylinder"),ke=V("sphere"),Be=V("plane");export{De as B,Ie as C,Ae as H,Be as P,ke as S};
